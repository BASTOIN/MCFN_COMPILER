# ast 수정사항
ast 말고 lark라이브러리를 사용하면 문법 정의만 해도 자동으로 ast를 작성해준다고 하니 수정하기.

# using 추가
using 은 이런식으로 사용한다.
```
#using{
	<string>;
	<string>;
	<string>;
}

func main(){}
...
```
이런식으로 코드의 가장 위에서 쓰며, \<string\>에는 다음에 서술하는 인수만 들어갈 수 있다:

`initializer;` : 이니셜라이저는 앞 코드에서 추가한 모든 const,\[Q1\],var,obj 를 삭제하고 재정의한다(리셋). 리셋후 재정의 순서는 이렇게 된다 : `obj -> var -> const -> [Q1]`  이니셜라이저는 /reload 했을때 즉, 데이터팩이 불러와졌을때 `_ready(){}` 와 같이 한번만 실행된다.

`no_queue;` : 큐 정의를 하지 않는다. 즉 이 .mcfn파일로 만들어진 모든 .mcfunction이 한 틱 안에 전부 실행되게 강제한다. ++queue 관련 구문(\[Q1\], set_queue등) 사용시 오류를 뱉는다.

+추후 더 추가할 예정이다.

# define 추가
define은 mcstacker와 비슷하게 사용할 수 있다.
```
#define zombie_set {
	Health:20,
	//무튼 마인크래프트에서 지원하는 json/nbt/snbt 그대로 적기
	Tags:{["asdf"]}
}
#define texts {
	color:"red"
	text:"asdf"
}

func main() {
	run(def"summon zombie ~ ~ ~ $zombie_set\0"); //zombie_set nbt 달린 좀비 소환
	run(def"tellraw @a $texts\0");
	run(def"execute as @e[nbt=$zombie_set\0] at @s");
}
```

이와같이 \#define \<string\> {} 으로 정의하고, $\<string\>\\0 으로 사용가능.
define은 json형식으로 작성/저장/사용 된다다


# func 함수 예약어로 인수 받기 추가
파이썬으로 예시를 들면
```py
def foo(x,y):
	#코드들 실행
	print(x,y)

a=1
b=2

foo(a,b)
```
와 같이

```mcfn
func foo(k, l, f){
	a:x += *k;
	a:y -= *l;
	const e = *f;
	//그리고
	if(*k == 1){}
	while(*l){}
	//call 도 동일하게 사용가능
}

func main(){
	obj a(dummy); var a:n; const a = 9;
	call foo(a:n, &a, 3);
}
```
이런식으로 쓸 수 있다.

설명하자면:
func foo(k,l){} 로 인자를 받았을때 k와l은 storage를 이용해 저장된다(\<namespace\>\_foo:k, \<namespace\>\_\<펑션파일이름\>:l 등).
저 인자는 \*k, \*l 등으로 불러올 수 있다. 이 \*k 값은 call에서 인자를 받은 직후 수정이 불가하다. 단, run(); 을 이용해 강제로 바꿀 수야 있다.

const를 개편해야 한다. 이 내용은 다음 페이지에서 다룬다

# const 수정사항
const 는 기존에 마커를 불러와서 데이터를 저장했었다. 이 기능은 마커가 청크이슈로 불러와지지 않았을때 문제가 발생할 수 있다. const저장방식과 규칙을 다음같이 바꾼다

`const A = 9;` 등으로 리셋하고 storage를 이용하여 `< --ns namesp 로 받은 네임스페이스>_<선언한 펑션 이름>:A` 에 저장한다
저장된 값을 불러오고 싶을때 `&` 를 이용한다(역으로 &를 이용한 저장은 불가하다.). 예:
`a:x = &A`; //정상
`if(a:x == &A){}`//정상
`&A = 1; //오류 발생`

같은 파일내 const 중복 선언(수정)이 가능하다. 예
```mcfn
func foo(){
	const A = 0;
	const A = 1;
}
```
const 는 다른 var과 다르게 선언한 파일에서만 사용 가능하다(그 func 의 하위 Queue 포함)
```mcfn
func foo(){
	const a = 0;
	
	if(a:x == &a){} //가능
	if(&a == 1){} //가능
	while(&a){}// 가능
}
func foo2(){
	a:x = &a; // 오류 발생
}
```

# func예약어 추가 및 지연 반복문 추가
func에 \_ready(){} 와 \_tick(){}을 추가한다.
```test.mcfn
func _ready(){
	//여기 내부의 코드는 데이터팩을 불러온 직후 한번만 실행한다.(.json 자동설정, 피일명: <mcfn파일명>_ready.mcfunction)
}

func _tick(){
	//여기 내부의 코드는 매 틱마다 실행된다(.json 자동설정, 파일명: <mcfn파일명>_tick.mcfunction)
}
```

기존 while로 반복할 수 있지만, while은 그래로 두고, 아래 명령을 추가한다.
```mcfn
func asdf(){
	rep_call foo(20);
}

func foo(){

}
```
rep_call 은 call 과 비슷한 명령이지만 다르다. 일단 rep_call은 call과 같이 변수 인수를 받지 않는다. 받는 인수는 얼마나 함수실행을 딜레이 할 것인지(const 제외한 숫자int상수)만 받을 수 있다. 그 이외값은 무시된다. 추가로 call과 달리 큐를 받지 않는다. 예:
```mcfn
func foo() {
	//코드 덩어리
}
func main() {
	
	rep_call foo(30, 4); //30 틱 이후 반복, 예상되지 않은 인수인 4는 무시됨 컴파일은 되지만, 경고 뱉기
}
```
이 반복은 schedule의 append 를 이용한다.

# queue(); 명령 추가

기존 queue 명령은 if, while, call에만 유효했으나
이 코드를 추가하면 일반 코드 안에 강제로 queue를 나눈다
```mcfn
func fun(){
	//
	//명령 1
	//
	
	if( ~~~ )[Q1]{ ~~~ }
	//
	//명령 2
	//
	
	set_queue()[Q2];
	//
	//명령 3
	//
}

```
이 코드에서 set_queue 는 if에 붙는 queue와 같이 schedule로 제어한다. 단,
`set_queue(<intiger>)[Q];` 식으로 작성한다(비워둘시 초깃값 1).
`set_queue(a:x)[Q];`  그러나 const 사용은 불가능하다.
`set_queue(3)[Q];` 같이 \<intiger\> 값을 받는다 schedule 을 이용하여 \<intiger\> 만큼 딜레이한다.

# 추가할 패스스루
run, runs를 유지함과 동시에 '/' 를 추가한다. 예:
```mcfn
func main() {
	run("say 1");
	runs{
		say 2
		say 3
	}
	/say 4 \0
}
```
'/' 에서는 문장의 끝을 인식하기위해 뒷쪽에 세미콜론 대신 널 문자 '\0' 를 인식한다.

# 추가 연산식
곱셈 나눗셈 곱셈대입 나눗셈대입
`*`, `/`, `*=`, `/=`
